"""Class to analyze the pip advisory database."""

import os
import subprocess
from datetime import datetime

from yaml import safe_load

from pip_security_worker import settings
from pip_security_worker.models.advisory import Advisory
from pip_security_worker.settings import PIP_ADVISORY_DB_URL
from pip_security_worker.vulnerability_database.advisory_base import \
    AdvisoryBase


class PIPAdvisory(AdvisoryBase):
    """Class to analyze the pip advisory database."""

    __slots__ = ('_last_updated',)

    def __init__(self) -> None:
        """Initialize the class."""
        self._last_updated = None

    @property
    def last_updated(self) -> datetime:
        """Return the last updated date."""
        return self._last_updated

    def __enter__(self):
        """Enter the context manager."""
        subprocess.run(['rm', '-rf', PIP_ADVISORY_DB_URL, settings.GIT_STORAGE])
        subprocess.run(['git', 'clone', PIP_ADVISORY_DB_URL, settings.GIT_STORAGE])
        updated = subprocess.run(
            ['git', f'--git-dir={settings.GIT_STORAGE}.git/', '--no-pager', 'log', '-1', '--format="%ai"'],
            capture_output=True,
        )
        self._last_updated = datetime.strptime(
            updated.stdout.decode('utf-8').strip().strip('"'), '%Y-%m-%d %H:%M:%S %z'
        )
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Exit the context manager."""
        subprocess.run(['rm', '-rf', PIP_ADVISORY_DB_URL, settings.GIT_STORAGE])

    # def __iter__(self):
    #    """Return the iterator object."""
    #    return self

    def _process_advisory(self, advisory_file: str) -> list[Advisory]:
        """Process the advisory."""
        advisories = []
        with open(advisory_file, 'r') as fh:
            advisory_data = fh.read()
            advisory_dict = safe_load(advisory_data)

            references: dict[str, str] = {
                reference['type']: reference['url'] for reference in advisory_dict.get('references', {})
            }
            for iter in range(len(advisory_dict['affected'])):
                security_type: str | None = None
                severity_score: str | None = None

                if len(advisory_dict.get('severity', [])) > 0:
                    security_type = advisory_dict['severity'][0]['type']
                    severity_score = advisory_dict['severity'][0]['score']

                affected_versions = []
                if 'versions' in advisory_dict['affected'][iter]:
                    affected_versions = list(advisory_dict['affected'][iter]['versions'])

                advisories.append(
                    Advisory(
                        name=advisory_dict['affected'][iter]['package']['name'],
                        url=advisory_dict['affected'][iter]['package'].get('purl', None),
                        versions=affected_versions,
                        security_type=security_type,
                        severity_score=severity_score,
                        description=advisory_dict['details'],
                        published=advisory_dict.get('published', advisory_dict.get('modified')),
                        advisory_id=advisory_dict.get('id', 'UNKNOWN'),
                        references=references,
                        raw=advisory_data,
                    )
                )
        return advisories

    def test(self):
        """Return the next advisory."""
        vulns_path = f'{settings.GIT_STORAGE}vulns'
        folders = os.listdir(vulns_path)
        for folder in folders:
            if folder.startswith('.'):
                continue
            folder_path = os.path.join(vulns_path, folder)
            files = os.listdir(folder_path)
            for file in files:
                if file.startswith('.'):
                    continue
                yield from self._process_advisory(os.path.join(folder_path, file))
        # raise StopIteration
