"""Class to analyze the pip advisory database."""

import logging
import os
import shutil
import subprocess
from datetime import datetime

from dateutil.parser import parse
from yaml import safe_load

from pip_security_worker import settings
from pip_security_worker.helpers.exceptions import GeneralError
from pip_security_worker.models.advisory import Advisory
from pip_security_worker.settings import PIP_ADVISORY_DB_URL

LOG = logging.getLogger(__name__)


class PIPAdvisory(object):
    """Class to analyze the pip advisory database."""

    __slots__ = ('_last_updated', '_fetched')

    def __init__(self) -> None:
        """Initialize the class."""
        LOG.debug('PIPAdvisory:__init__ - Initializing PIPAdvisory')
        self._last_updated: datetime | None = None
        self._fetched: bool = False

    @property
    def last_updated(self) -> datetime:
        """
        Property for the last update datetime of the advisory database.

        This returns the last update datetime if it exists, otherwise datetime representing now. Now should only
        be returned if a context manager has not been created.

        Returns:
            last update as a datetime if exists, otherwise datetime representing now.
        """
        LOG.debug('PIPAdvisory:last_updated - Getting last updated datetime')
        self._fetch_repository()
        return self._last_updated or datetime.now()

    def _fetch_repository(self) -> None:
        """
        Fetch the repository.

        Raises:
            GeneralError: On failure to delete the repository.
        """
        LOG.debug('PIPAdvisory:_fetch_repository - Fetching repository')
        if self._fetched:
            LOG.debug('PIPAdvisory:_fetch_repository - Repository has already been fetched, skipping')
            # Repository has already been fetched, we don't need to fetch it again.
            return

        try:
            shutil.rmtree(settings.GIT_STORAGE)
            LOG.info('PIPAdvisory:_fetch_repository - Deleted git repository')
        except FileNotFoundError:
            LOG.debug('PIPAdvisory:_fetch_repository - No git repository found')
        except Exception as exc:
            LOG.critical(f'PIPAdvisory:_fetch_repository - Failed to delete git repository: {exc}')
            raise GeneralError('Failed to delete git repository') from exc

        subprocess.run(['git', 'clone', PIP_ADVISORY_DB_URL, settings.GIT_STORAGE])
        updated = subprocess.run(
            ['git', f'--git-dir={settings.GIT_STORAGE}.git/', '--no-pager', 'log', '-1', '--format="%ai"'],
            capture_output=True,
        )
        LOG.debug(f'PIPAdvisory:_fetch_repository - Last updated: {updated}')
        self._last_updated = datetime.strptime(
            updated.stdout.decode('utf-8').strip().strip('"'), '%Y-%m-%d %H:%M:%S %z'
        )
        self._fetched = True

    def __enter__(self) -> 'PIPAdvisory':
        """Enter the context manager."""
        LOG.debug('PIPAdvisory:__enter__ - Entering context manager')
        self._fetch_repository()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Exit the context manager."""
        LOG.debug('PIPAdvisory:__exit__ - Exiting context manager, deleting the git repository')
        try:
            shutil.rmtree(settings.GIT_STORAGE)
            LOG.info('PIPAdvisory:__exit__ - Deleted git repository')
        except Exception as exc:
            LOG.critical(f'PIPAdvisory:__exit__ - Failed to delete git repository: {exc}')
        self._fetched = False

    @staticmethod
    def _process_advisory(advisory_file: str) -> list[Advisory]:
        """Process the advisory."""
        LOG.debug(f'PIPAdvisory:_process_advisory - Processing advisory {advisory_file}')
        advisories = []
        with open(advisory_file, 'r') as fh:
            advisory_data = fh.read()
            advisory_dict = safe_load(advisory_data)

            references: dict[str, str] = {
                reference['type']: reference['url'] for reference in advisory_dict.get('references', {})
            }
            LOG.debug(f'PIPAdvisory:_process_advisory - {advisory_dict["affected"]}, packages found in advisory')
            for item in range(len(advisory_dict['affected'])):
                security_type: str | None = None
                severity_score: str | None = None

                if len(advisory_dict.get('severity', [])) > 0:
                    security_type = advisory_dict['severity'][0]['type']
                    severity_score = advisory_dict['severity'][0]['score']

                affected_versions = []
                if 'versions' in advisory_dict['affected'][item]:
                    affected_versions = list(advisory_dict['affected'][item]['versions'])
                LOG.debug(f'PIPAdvisory:_process_advisory - Found {len(affected_versions)} affected versions')
                published = advisory_dict.get('published', advisory_dict.get('modified'))
                if type(published) is str:
                    published = parse(advisory_dict.get('published', advisory_dict.get('modified')))
                advisories.append(
                    Advisory(
                        name=advisory_dict['affected'][item]['package']['name'],
                        url=advisory_dict['affected'][item]['package'].get('purl', None),
                        versions=affected_versions,
                        security_type=security_type,
                        severity_score=severity_score,
                        description=advisory_dict['details'],
                        published=published,
                        advisory_id=advisory_dict.get('id', 'UNKNOWN'),
                        references=references,
                        raw=advisory_data,
                    )
                )
                LOG.debug(
                    f'PIPAdvisory:_process_advisory - Added advisory {advisory_dict["affected"][item]["package"]["name"]}'
                )
        return advisories

    def run(self):
        """Return the next advisory."""
        LOG.debug('PIPAdvisory:run - Starting run')
        vulns_path = f'{settings.GIT_STORAGE}vulns'
        folders = os.listdir(vulns_path)
        LOG.debug(f'PIPAdvisory:run - Found {len(folders)} folders in {vulns_path}')
        for folder in folders:
            if folder.startswith('.'):
                continue
            folder_path = os.path.join(vulns_path, folder)
            files = os.listdir(folder_path)
            LOG.debug(f'PIPAdvisory:run - Found {len(files)} files in {folder_path}')
            for file in files:
                if file.startswith('.'):
                    LOG.debug(f'PIPAdvisory:run - Skipping file {file}')
                    continue
                yield from self._process_advisory(advisory_file=os.path.join(folder_path, file))
